<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#000000" />
  <title>TF-Stream</title>
  <!-- PWA manifest et icônes -->
  <link rel="manifest" href="manifest.json" />
  <link rel="icon" type="image/jpeg" href="https://files.catbox.moe/ixgmht.jpg" />
  <link rel="apple-touch-icon" href="https://files.catbox.moe/ixgmht.jpg" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet" />
  <style>
    body { margin:0; background:#000; color:#fff; font-family:'Roboto',sans-serif; overflow-x:hidden; padding-bottom:60px; }
    .header{padding:20px;text-align:center;position:sticky;top:0;backdrop-filter:blur(10px);background:rgba(0,0,0,0.7);z-index:10;}
    .logo{font-size:28px;font-weight:bold;background:linear-gradient(90deg,#fff,#000);-webkit-background-clip:text;-webkit-text-fill-color:transparent;filter:blur(0.5px);}
    .filter-bar{display:flex;justify-content:center;gap:10px;margin:10px 0;flex-wrap:wrap;}
    .filter-btn{background:#222;color:#fff;border:none;padding:6px 14px;border-radius:30px;cursor:pointer;}
    .filter-btn.active{background:#444;}
    .search-container{display:flex;justify-content:center;padding:10px 20px;}
    .search-box{width:100%;max-width:500px;background:#1c1c1e;border:none;padding:12px 20px;border-radius:15px;color:#fff;font-size:16px;box-shadow:inset 0 0 5px #000;outline:none;}
    .video-list{display:flex;flex-wrap:wrap;gap:15px;padding:20px;justify-content:center;}
    .video-card{position:relative;width:110px;background:#111;border-radius:10px;overflow:hidden;cursor:pointer;transition:transform .2s;}
    .video-card:hover{transform:scale(1.03);}
    .video-card img{width:100%;display:block;}
    .card-overlay{position:absolute;inset:0;background:rgba(0,0,0,0.6);opacity:0;display:flex;align-items:center;justify-content:center;transition:opacity .3s;}
    .video-card:hover .card-overlay{opacity:1;}
    .play-icon{font-size:40px;color:#fff;}
    .info{padding:6px;text-align:center;font-size:13px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
    .nav-bar{position:fixed;bottom:0;width:100%;background:#111;display:flex;justify-content:space-around;padding:10px 0;z-index:20;border-top:1px solid #333;}
    .nav-btn{background:none;border:none;color:#aaa;font-size:14px;text-align:center;flex:1;cursor:pointer;}
    .nav-btn.active{color:#fff;font-weight:bold;}
    #explorerView{padding:20px;max-height:calc(100vh-120px);overflow-y:auto;display:none;background:#000;-webkit-overflow-scrolling:touch;}
    .post-card{background:#111;border-radius:15px;padding:15px;margin-bottom:20px;box-shadow:0 2px 8px rgba(0,0,0,0.7);}
    .post-name{font-weight:700;font-size:17px;margin-bottom:8px;color:#fff;}
    .post-text{font-size:15px;color:#ddd;margin-bottom:10px;white-space:pre-wrap;}
    .social-section{margin-top:10px;padding-top:10px;border-top:1px solid #333;display:flex;justify-content:center;gap:15px;}
    .social-section img{width:40px;height:40px;}
    .overlay-fond{position:fixed;inset:0;background:rgba(0,0,0,0.8);backdrop-filter:blur(20px);display:none;justify-content:center;align-items:flex-start;padding:20px;overflow-y:auto;z-index:999;}
    .modal-container{background:#111;border-radius:10px;padding:20px;max-width:700px;width:100%;box-shadow:0 4px 20px rgba(0,0,0,0.8);position:relative;}
    .modal-container button{background:#444;color:#fff;border:none;padding:8px 14px;border-radius:6px;cursor:pointer;}
    .thumbnail{width:100%;max-height:300px;object-fit:cover;border-radius:6px;margin-bottom:12px;}
    .modal-title{font-size:24px;font-weight:700;margin-bottom:8px;}
    .modal-controls{display:flex;justify-content:space-between;align-items:center;margin-bottom:16px;}
    .season-list{position:absolute;top:60px;right:20px;background:#111;border-radius:6px;overflow:hidden;box-shadow:0 2px 10px rgba(0,0,0,0.7);display:none;}
    .season-list button{width:100%;padding:10px;text-align:left;background:#222;color:#fff;border:none;border-bottom:1px solid #333;cursor:pointer;}
    .modal-info{background:#111;border-radius:6px;padding:12px;font-size:14px;color:#ddd;margin-bottom:12px;display:none;}
    .modal-episodes{display:grid;grid-template-columns:1fr;gap:10px;}
    .episode-item{background:rgba(0,0,0,0.6);padding:12px;border-radius:8px;cursor:pointer;transition:transform .2s;}
    .episode-item:hover{transform:scale(1.02);}
    .episode-item.active { background: rgba(200,200,200,0.3); }
    .episode-item.visited { background: rgba(50,50,50,0.4); color: #aaa; font-weight: normal; }
    .ad-overlay{position:fixed;inset:0;background:rgba(0,0,0,0.9);display:none;justify-content:center;align-items:center;z-index:1000;}
    .ad-container{background:#111;padding:20px;border-radius:10px;text-align:center;}
    .ad-container button{background:#444;color:#fff;border:none;padding:10px 20px;border-radius:6px;cursor:pointer;}
/* Splash full-screen */
#splash {
  position: fixed;
  inset: 0;
  background: #000;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 9999;
  animation: splashPop 1.7s forwards;
}
.splash-logo {
  font-size: 3rem;
  font-weight: bold;
  background: linear-gradient(90deg, #fff, #000);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  filter: blur(0.5px);
  margin: 0;
  animation: logoPop 1.7s ease-out forwards;
}
.splash-version {
  margin-top: 0.5rem;
  color: #aaa;
  font-size: 1rem;
  animation: logoPop 1.7s ease-out forwards;
}
@keyframes splashPop {
  0%   { opacity: 1; }
  80%  { opacity: 1; }
  100% { opacity: 0; }
}
@keyframes logoPop {
  0%   { transform: scale(1);   opacity: 1; }
  50%  { transform: scale(1.2); opacity: 1; }
  80%  { transform: scale(1.1); opacity: 1; }
  100% { transform: scale(1.1); opacity: 0; }
}
    .media-container {
  width: 100%;
  height: 180px;
  overflow: hidden;
  border-radius: 8px;
  margin-bottom: 10px;
}
.media-container img,
.media-container video {
  width: 100%;
  height: 100%;
  object-fit: cover;
}
  </style>
</head>
<body>
  <!-- Splash Screen full-screen -->
  <div id="splash">
    <h1 class="splash-logo">TF-Stream</h1>
    <p class="splash-version">D'H7 | Tergene</p>
  </div>

  <!-- Overlay modal (UNIQUE) -->
  <div id="fondOverlay" class="overlay-fond"></div>

  <div class="header">
    <div class="logo">TF-Stream</div>
    <div class="filter-bar">
      <button class="filter-btn active" onclick="filterCategory('Tout',event)">Tout</button>
      <button class="filter-btn" onclick="filterCategory('Film',event)">Film</button>
      <button class="filter-btn" onclick="filterCategory('Série',event)">Série</button>
      <button class="filter-btn" onclick="filterCategory('Anime',event)">Anime</button>
    </div>
    <div class="search-container">
      <input class="search-box" placeholder="Rechèch..." oninput="filterSearch(this.value)">
    </div>
  </div>

  <div class="video-list" id="videoList"></div>
  <div id="explorerView"></div>

  <div class="nav-bar">
    <button class="nav-btn active" onclick="navigateTo('Accueil',event)">Accueil</button>
    <button class="nav-btn" onclick="navigateTo('Explorer',event)">Explorer</button>
  </div>

  <div id="adOverlay" class="ad-overlay">
    <div class="ad-container">
      <p>Publicité</p>
      <button id="adLinkBtn">En savoir plus</button>
      <button onclick="closeAd()">Fermer</button>
    </div>
  </div>

<script>
document.addEventListener('DOMContentLoaded', () => {
  // Prevent context menu (keeps original behaviour)
  document.addEventListener('contextmenu', e => e.preventDefault());

  // Social & ad config
  const socialLinks = {
    whatsapp: "https://whatsapp.com/channel/0029VbB3DwvLtOjCUY4RaK39",
    instagram: "https://www.instagram.com/tfstream7?igsh=ZmE2OHB3MjU5NWY3&utm_source=ig_contact_invite",
    facebook: "https://www.facebook.com/profile.php?id=61578064777470",
    youtube: "https://www.youtube.com/@TFStream7",
    gmail: "mailto:tfstream7@gmail.com"
  };
  const adUrl = "https://www.revenuecpmgate.com/twzv74qc?key=0090d4d72518c39ae43327f9f788a61e";
  let allData = [];

  // --- NEW: small toast element for PiP feedback ---
  (function createPipToast(){
    if (document.getElementById('pipToast')) return;
    const t = document.createElement('div');
    t.id = 'pipToast';
    t.style.position = 'fixed';
    t.style.bottom = '72px';
    t.style.left = '50%';
    t.style.transform = 'translateX(-50%)';
    t.style.background = 'rgba(0,0,0,0.8)';
    t.style.color = '#fff';
    t.style.padding = '8px 12px';
    t.style.borderRadius = '10px';
    t.style.fontSize = '13px';
    t.style.zIndex = '1100';
    t.style.display = 'none';
    t.textContent = 'Lecture réduite en PiP';
    document.body.appendChild(t);
  })();

  // Fetch index.json — supporte 2 formats:
  fetch('index.json')
    .then(r => r.json())
    .then(files => {
      if (Array.isArray(files) && files.length && typeof files[0] === 'string') {
        return Promise.all(files.map(f => fetch(f).then(r => r.json())));
      } else {
        return [files];
      }
    })
    .then(jsons => {
      jsons.forEach(d => Array.isArray(d) ? allData.push(...d) : allData.push(d));
      displayVideos(allData);
    })
    .catch(err => {
      console.error('Erreur fetch index/json:', err);
      // Optionnel: afficher message utilisateur
      const list = document.getElementById('videoList');
      if (list) list.innerHTML = '<p style="color:#aaa;text-align:center;width:100%;">Aucun contenu trouvé ou erreur de chargement.</p>';
    });

  // --- Core UI functions (robustes) ---
  function displayVideos(videos) {
    const list = document.getElementById('videoList');
    if (!list) return console.error('#videoList introuvable dans le DOM');
    list.innerHTML = '';
    const activeBtn = document.querySelector('.filter-btn.active');
    const cat = (activeBtn ? activeBtn.textContent : 'tout').toLowerCase();
    (videos || []).forEach((v, idx) => {
      const c = (v.Catégorie || v.category || '').toString().toLowerCase();
      if (c === 'poste') return;
      if (cat !== 'tout' &&
          ((cat === 'film' && c !== 'film') ||
           (cat === 'série' && c !== 'série' && c !== 'serie') ||
           (cat === 'anime' && c !== 'anime' && c !== 'animé'))) return;

      const thumbSrc = v['Url Thumb'] || v.urlThumb || v.thumb || 'thumb.jpg';
      const title = v.Titre || v.Name || v.Texte || 'Sans titre';

      const card = document.createElement('div');
      card.className = 'video-card';
      card.innerHTML = `
        <img src="${thumbSrc}" alt="${escapeHtml(title)}">
        <div class="card-overlay"><span class="play-icon">▶</span></div>
        <div class="info">${escapeHtml(title)}</div>
      `;
      card.onclick = () => showPostModal(v, idx);
      list.appendChild(card);
    });
  }

  // Helpers
  function escapeHtml(s) { return String(s || '').replace(/[&<>"']/g, ch => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[ch])); }

  // Exposure to inline HTML attributes
  window.filterCategory = function(_, e) {
    document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
    e.target.classList.add('active');
    displayVideos(allData);
  };

  window.filterSearch = function(val) {
    displayVideos(allData.filter(i => (i.Titre||i.Name||i.Texte||'').toString().toLowerCase().includes(String(val||'').toLowerCase())));
  };

  window.navigateTo = function(sec, e) {
    document.querySelectorAll('.nav-btn').forEach(b => b.classList.remove('active'));
    e.target.classList.add('active');
    document.getElementById('videoList').style.display = 'none';
    document.getElementById('explorerView').style.display = 'none';
    document.querySelector('.filter-bar').style.display = 'none';
    document.querySelector('.search-container').style.display = 'none';
    if (sec === 'Accueil') {
      document.getElementById('videoList').style.display = 'flex';
      document.querySelector('.filter-bar').style.display = 'flex';
      document.querySelector('.search-container').style.display = 'flex';
    } else {
      displayExplorer();
      document.getElementById('explorerView').style.display = 'block';
      document.querySelector('.search-container').style.display = 'flex';
    }
  };

  // Explorer (swipe -> play inline)
  function displayExplorer() {
    const ex = document.getElementById('explorerView');
    if (!ex) return;
    ex.innerHTML = '';
    (allData.filter(p => (p.Catégorie||'').toString().toLowerCase()==='poste') || []).forEach(post => {
      const thumbUrl = post['Url Thumb'] || post.thumb || '';
      const videoUrl = post.Previously || post['Previously '] || post.video || post.Video || '';
      const card = document.createElement('div'); card.className = 'post-card';
      card.innerHTML = `
        <div class="media-container">
          <img class="thumb" src="${escapeHtml(thumbUrl)}" alt="Vignette">
        </div>
        <div class="post-name">${escapeHtml(post.Name||post.Titre||'')}</div>
        <div class="post-text">${escapeHtml(post.Description||post.Bio||'')}</div>
      `;
      ex.appendChild(card);
      if (videoUrl) {
        let startX = 0;
        card.addEventListener('touchstart', e => startX = e.changedTouches[0].clientX);
        card.addEventListener('touchend', e => {
          const endX = e.changedTouches[0].clientX;
          if (Math.abs(endX - startX) > 50) {
            const media = card.querySelector('.media-container');
            media.innerHTML = `<video src="${escapeHtml(videoUrl)}" controls autoplay style="width:100%;border-radius:8px"></video>`;
          }
        });
      }
    });
    // social links
    const s = document.createElement('div'); s.className='social-section';
    s.innerHTML = `
      <a href="${socialLinks.facebook}" target="_blank"><img src="https://img.icons8.com/?size=100&id=118467&format=png&color=ffffff"/></a>
      <a href="${socialLinks.gmail}" target="_blank"><img src="https://img.icons8.com/?size=100&id=Y2GfpkgYNp42&format=png&color=ffffff"/></a>
      <a href="${socialLinks.whatsapp}" target="_blank"><img src="https://img.icons8.com/?size=100&id=16733&format=png&color=ffffff"/></a>
      <a href="${socialLinks.instagram}" target="_blank"><img src="https://img.icons8.com/?size=100&id=32309&format=png&color=ffffff"/></a>
      <a href="${socialLinks.youtube}" target="_blank"><img src="https://img.icons8.com/?size=100&id=37326&format=png&color=ffffff"/></a>
    `;
    ex.appendChild(s);
  }

  // close ad helper (kept from original)
  window.closeAd = function() {
    document.getElementById('adOverlay').style.display = 'none';
  };

  // --- NEW: modal + history + PiP handling ---
  let modalOpen = false;
  let modalHistoryPushed = false;
  let currentVideoEl = null;
  const pipToast = document.getElementById('pipToast');

  function showPipToast() {
    if (!pipToast) return;
    pipToast.style.display = 'block';
    clearTimeout(pipToast._t);
    pipToast._t = setTimeout(()=> pipToast.style.display = 'none', 1800);
  }

  // close modal immediately (used by UI back & popstate)
  function closeModalImmediate() {
    const overlay = document.getElementById('fondOverlay');
    if (!overlay) return;
    // save playback time
    try {
      const storageKey = overlay.dataset.storageKey;
      if (storageKey && currentVideoEl && currentVideoEl.src) {
        const prev = JSON.parse(localStorage.getItem(storageKey || '') || '{}');
        prev.playbackTimes = prev.playbackTimes || {};
        prev.playbackTimes[currentVideoEl.src] = currentVideoEl.currentTime || 0;
        localStorage.setItem(storageKey || '', JSON.stringify(prev));
      }
    } catch(e) { /* ignore */ }

    overlay.style.display = 'none';
    modalOpen = false;

    // pause and cleanup currentVideoEl to avoid strange pause/resume bugs
    try {
      if (currentVideoEl) {
        currentVideoEl.pause();
        // remove src to stop network + avoid stuck playback state
        currentVideoEl.removeAttribute('src');
        if (typeof currentVideoEl.load === 'function') currentVideoEl.load();
      }
    } catch(e){}

    currentVideoEl = null;

    // pop the history state we added when modal opened (only if it's still present)
    if (modalHistoryPushed) {
      try {
        if (history.state && history.state.tfstreamModal) history.back();
      } catch(e){}
      modalHistoryPushed = false;
    }
  }

  // handle hardware back: if modal open, close it immediately
  window.addEventListener('popstate', (e) => {
    if (modalOpen) {
      closeModalImmediate();
    }
  });

  // Try to enter PiP when page is hidden or pagehide fired (long back / minimize)
  async function tryEnterPiP(autoMute = true) {
    if (!modalOpen || !currentVideoEl) return;
    const video = currentVideoEl;
    if (!document.pictureInPictureEnabled || !video.requestPictureInPicture) return;
    if (document.pictureInPictureElement) return; // already in pip
    try {
      const prevMuted = video.muted;
      if (autoMute) video.muted = true;
      await video.requestPictureInPicture();
      showPipToast();
      // restore mute state on leave PiP
      video.addEventListener('leavepictureinpicture', function restoreMuteOnce() {
        try { video.muted = prevMuted; } catch(e){}
        video.removeEventListener('leavepictureinpicture', restoreMuteOnce);
      });
    } catch(err) {
      // fail silently (not all browsers allow programmatic PiP)
      console.warn('PiP request failed or blocked:', err);
    }
  }

  document.addEventListener('visibilitychange', () => {
    if (document.hidden) tryEnterPiP(true);
  });
  window.addEventListener('pagehide', () => tryEnterPiP(true));

  // showPostModal: enhanced with history push and PiP support
  window.showPostModal = function(post, postIndex) {
    const overlay = document.getElementById('fondOverlay');
    if (!overlay) return console.error('fondOverlay introuvable');

    overlay.innerHTML = `
      <div class="modal-container" role="dialog" aria-modal="true">
        <button id="backBtn">← Retour</button>
        <video id="modalThumb" class="thumbnail" controls playsinline controlsList="nodownload"></video>
        <div id="modalTitle" class="modal-title"></div>
        <div class="modal-controls">
          <button id="infoBtn">Voir plus…</button>
          <button id="seasonBtn">Saison 1</button>
        </div>
        <div id="seasonList" class="season-list" aria-hidden="true"></div>
        <div id="modalInfo" class="modal-info"></div>
        <div id="episodeList" class="modal-episodes"></div>
      </div>
    `;
    overlay.style.display = 'flex';

    // push history state so hardware back closes modal first
    modalOpen = true;
    try {
      history.pushState({ tfstreamModal: true }, '', window.location.href + '#TF-Stream');
      modalHistoryPushed = true;
    } catch(e){ modalHistoryPushed = false; }

    const thumb = document.getElementById('modalThumb'),
          titleEl = document.getElementById('modalTitle'),
          infoBtn = document.getElementById('infoBtn'),
          seasonBtn = document.getElementById('seasonBtn'),
          seasonList = document.getElementById('seasonList'),
          infoEl = document.getElementById('modalInfo'),
          epList = document.getElementById('episodeList'),
          saisons = post.Saisons || post.Seasons || [];

    const storageKey = `post-${postIndex}-state`;
    overlay.dataset.storageKey = storageKey;

    let saved = {};
    try { saved = JSON.parse(localStorage.getItem(storageKey) || '{}'); } catch(e){ saved = {}; }
    let playbackTimes = saved.playbackTimes || {};
    let visited = saved.visited || {};

    titleEl.textContent = post.Titre || post.Name || 'Sans titre';
    let currentSeason = 0, selectedEpEl = null;

    function saveState() {
      try {
        localStorage.setItem(storageKey, JSON.stringify({
          lastVideoUrl: thumb.src,
          playbackTimes,
          visited
        }));
      } catch(e) { console.warn('LocalStorage save failed', e); }
    }

    function renderInfo() {
      const s = saisons[currentSeason] || {};
      infoEl.innerHTML = `
        <strong>Description:</strong> ${escapeHtml(s.description||'')}<br>
        <strong>Bio:</strong> ${escapeHtml(s.bio||s.Bio||'')}<br>
        <strong>Info:</strong> ${escapeHtml(s.info||s.Info||'')}
      `;
      infoEl.style.display = 'block';
    }
    infoBtn.onclick = () => infoEl.style.display = infoEl.style.display === 'block' ? 'none' : 'block';

    // render seasons
    seasonList.innerHTML = '';
    (saisons || []).forEach((s,i) => {
      const b = document.createElement('button');
      b.textContent = `Saison ${i+1}`;
      b.onclick = () => {
        currentSeason = i;
        seasonBtn.textContent = `Saison ${i+1}`;
        renderInfo(); renderEpisodes();
        seasonList.style.display = 'none';
      };
      seasonList.appendChild(b);
    });
    seasonBtn.onclick = () => seasonList.style.display = seasonList.style.display === 'block' ? 'none' : 'block';

    function renderEpisodes() {
      epList.innerHTML = '';
      const seasonObj = saisons[currentSeason] || { episodes: [] };
      (seasonObj.episodes || []).forEach((ep, i) => {
        const d = document.createElement('div');
        d.className = 'episode-item';
        d.innerHTML = `<strong>Episode ${i+1}</strong><div>${escapeHtml(ep.description||'')}</div>`;
        if (visited[ep.video]) d.classList.add('visited');

        d.onclick = async () => {
          // mark previous playback time before switching
          if (thumb.src) playbackTimes[thumb.src] = thumb.currentTime || 0;

          if (selectedEpEl) selectedEpEl.classList.remove('active');
          d.classList.add('active');
          selectedEpEl = d;

          // set video src and try to play first (user clicked -> should allow sound)
          thumb.src = ep.video;
          currentVideoEl = thumb;
          thumb.currentTime = playbackTimes[ep.video] || 0;

          // make sure not muted (user interacted)
          try { thumb.muted = false; } catch(e){}

          // Try to play; once play succeeds (or even if it fails), open ad in new tab
          try {
            await thumb.play();
          } catch(playErr) {
            console.warn('Autoplay blocked or failed:', playErr);
          } finally {
            // open ad AFTER attempting to play so we don't lose the user gesture
            try { window.open(adUrl, '_blank'); } catch(e) { console.warn('Ad open failed', e); }
          }

          // mark visited after >2s
          const onTime = () => {
            if (thumb.currentTime > 2) {
              d.classList.add('visited');
              visited[ep.video] = true;
              thumb.removeEventListener('timeupdate', onTime);
              saveState();
            }
          };
          thumb.addEventListener('timeupdate', onTime);
          saveState();
        };

        epList.appendChild(d);
      });
    }

    renderInfo();
    renderEpisodes();

    // restore lastVideoUrl without opening ad
    if (saved.lastVideoUrl) {
      const seasonObj = saisons[currentSeason] || {};
      Array.from(epList.children).forEach((el, i) => {
        const ep = (seasonObj.episodes || [])[i];
        if (ep && ep.video === saved.lastVideoUrl) {
          el.classList.add('active');
          selectedEpEl = el;
          thumb.src = ep.video;
          currentVideoEl = thumb;
          thumb.currentTime = playbackTimes[ep.video] || 0;
        }
      });
    } else {
      // If there is a main video for the post (single video), start it right away (user clicked card => gesture)
      const initialVideo = post.Video || post.video || post['Previously'] || post['Previously '] ||
                           (saisons[0] && saisons[0].episodes && saisons[0].episodes[0] && saisons[0].episodes[0].video) || '';
      if (initialVideo) {
        thumb.src = initialVideo;
        currentVideoEl = thumb;
        try { thumb.muted = false; } catch(e){}
        try {
          thumb.currentTime = playbackTimes[initialVideo] || 0;
          thumb.play().catch(err => console.warn('Autoplay failed on modal open:', err));
        } catch(e){ console.warn('Play fail', e); }
      }
    }

    // UI Back button: close immediately (no ad)
    document.getElementById('backBtn').onclick = () => {
      try { if (thumb && thumb.src) playbackTimes[thumb.src] = thumb.currentTime; } catch(e){}
      saveState();
      closeModalImmediate();
    };

    // click outside modal closes immediate too
    overlay.onclick = (ev) => {
      if (ev.target === overlay) {
        try { if (thumb && thumb.src) playbackTimes[thumb.src] = thumb.currentTime; } catch(e){}
        saveState();
        closeModalImmediate();
      }
    };

    // Optional: listen for enter/exit PiP to show toast (immediate feedback)
    thumb.addEventListener('enterpictureinpicture', () => {
      showPipToast();
    });

  }; // end showPostModal

  // Service Worker registration + message handling (unchanged)
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('/sw.js', { scope: '/' })
      .then(reg => {
        console.log('SW registered, scope:', reg.scope);
        navigator.serviceWorker.ready.then(regReady => {
          if (regReady.active && regReady.active.postMessage) {
            regReady.active.postMessage({ type: 'LIST_CACHES' });
          }
        });
      })
      .catch(err => console.error('SW reg failed', err));

    navigator.serviceWorker.addEventListener('message', ev => {
      if (ev.data && ev.data.type === 'CACHES_LIST') {
        console.log('SW caches list:', ev.data.payload);
      } else if (ev.data && ev.data.type === 'CACHES_ERROR') {
        console.error('SW caches error:', ev.data.payload);
      } else {
        console.log('SW message:', ev.data);
      }
    });
  } else {
    console.warn('Service Worker not supported');
  }

  // remove splash after animation
  setTimeout(() => {
    const splash = document.getElementById('splash');
    if (splash) splash.remove();
  }, 1700);

}); // DOMContentLoaded
</script>
</body>
</html>
